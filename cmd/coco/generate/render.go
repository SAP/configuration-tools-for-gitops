package generate

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	gotemplate "text/template"

	"github.com/configuration-tools-for-gitops/pkg/log"
	"github.com/configuration-tools-for-gitops/pkg/version"
	"github.com/configuration-tools-for-gitops/pkg/yamlfile"
)

const (
	// genFileHeader will be added at the top of every file that has been generated
	// or altered by coco. The current coco version is rendered in dynamically.
	// This line is also used to check whether a generated file was created from a
	// different version of coco.
	genFileHeader = "# Code generated by CLI 'coco generate ...' (version: %v.%v); DO NOT EDIT.\n\n"

	allAllowed = 0777
)

var (
	yamlProcessor func([]byte, []byte, string) ([]byte, []yamlfile.Warning, error) = mergeSort

	parserConfig parserMock = parserMock{Mock: false}

	reVersion = regexp.MustCompile(
		`# Code generated by CLI 'coco generate ...' \(version: ([0-9]*)\.([0-9]*).*\); DO NOT EDIT.`,
	)
)

type template struct {
	// source holds the path to the template file that must be used for rendering
	source string
	// basepath holds the path to the folder in which the .tmpl file (or folder)
	// resides
	basepath string
	// namePrefix holds the prefix that will be attached to the rendered filename.
	// E.g. "name.tmpl" -> "name-${full_cluster_name}.yaml"
	namePrefix string
	// subpaths is empty for .tmpl files but for .tmpl folders it holds the subpaths
	// inside the .tmpl folder. E.g. ".tmpl/a/b/hello.yaml" -> "a/b/hello.yaml"
	subpath string
}

// The render function is the core of the file generation. It renders all provided
// templates for all provided values (environments) and saves the resulting yaml
// files in the dedicated paths (see ./readme.md for further details on file names).
func render(
	name string, tmpls []template, vals map[string]interface{},
	reportChan chan<- renderReport,
	logLvl log.Level,
	persistenceComment string,
	v *version.Version,
	takeControl bool,
) {
	report := renderReport{}

	var p parserInt
	if parserConfig.Mock {
		p = parserConfig
	} else {
		p = &parser{}
	}

	for _, tmpl := range tmpls {
		c := ctx{
			log.Context{"template": tmpl.source},
			&report,
			reportChan,
		}
		c.AddDebug(logLvl, "go-routine", name)

		err := p.parse(tmpl.source, tmplFuncs())
		if c.checkErr("parse template error", err) {
			return
		}

		for env, values := range vals {
			c.AddDebug(logLvl, "values", fmt.Sprintf("%+v", values))

			fp := filePath(env, tmpl)
			c.Context["file"] = fp
			c.Log("processing values", log.Debug())

			previousContent, err := readFile(fp)
			if c.checkErr("read current file error", err) {
				return
			}

			// no file generation when the following conditions are met:
			// - takeControl flag is false (only generated files with matching version are overwritten)
			// - the previous version of the file is not empty
			// - the versions of coco and the version in the generated file do not match
			if !takeControl &&
				len(previousContent) != 0 &&
				versionIncompatible(previousContent, v.SemVer) {
				continue
			}

			generated, err := p.execute(values)
			if c.checkErr("render template error", err) {
				return
			}

			newFile, warnings, err := processFile(fp, previousContent, generated, persistenceComment)
			if c.checkErr("MergeSort failed", err) {
				return
			}
			headlessContent, err := removeHeader(previousContent, genFileHeader)
			if c.checkErr("remove header failed", err) {
				return
			}
			if reflect.DeepEqual(newFile, headlessContent) {
				continue
			}
			for _, w := range warnings {
				c.addReport(w.Warning, log.Warn(), log.Context{"keys": w.Keys})
			}

			err = writeToFile(
				fp,
				fmt.Sprintf(genFileHeader, v.SemVer.Major, v.SemVer.Minor),
				newFile,
			)
			if c.checkErr("write to file error", err) {
				return
			}
		}
	}
	reportChan <- report
}

func readFile(path string) ([]byte, error) {
	content, err := os.ReadFile(path)
	if errors.Is(err, os.ErrNotExist) {
		content = []byte{}
		err = nil
	}
	return content, err
}

func writeToFile(path, header string, content []byte) error {
	f, err := openFileAsEmpty(path, header)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = f.Write(content)
	return err
}

func removeHeader(content []byte, header string) ([]byte, error) {
	r := bufio.NewReader(bytes.NewReader(content))
	for i := strings.Count(header, "\n"); i > 0; i-- {
		if _, err := r.ReadBytes('\n'); err != nil {
			if err == io.EOF {
				err = nil
			}
			return []byte{}, err
		}
	}
	var headlessContent bytes.Buffer
	if _, err := r.WriteTo(&headlessContent); err != nil {
		return []byte{}, err
	}
	return headlessContent.Bytes(), nil
}

type parserInt interface {
	parse(filename string, funcs gotemplate.FuncMap) error
	execute(data interface{}) ([]byte, error)
}

type parserMock struct {
	Mock bool
	Err  error
}

func (m parserMock) parse(filename string, funcs gotemplate.FuncMap) error {
	return nil
}

func (m parserMock) execute(data interface{}) ([]byte, error) {
	return nil, m.Err
}

type parser struct {
	tmpl *gotemplate.Template
}

func (p *parser) parse(filename string, funcs gotemplate.FuncMap) error {
	b, err := os.ReadFile(filename)
	if err != nil {
		return err
	}
	parsed, err := gotemplate.New(filename).Funcs(funcs).Parse(string(b))
	if err != nil {
		return err
	}
	p.tmpl = parsed
	return nil
}

func (p parser) execute(data interface{}) ([]byte, error) {
	generated := new(bytes.Buffer)
	err := p.tmpl.Execute(generated, data)
	if err != nil {
		return nil, err
	}
	return generated.Bytes(), nil
}

func processFile(
	path string, from, into []byte, persistenceComment string,
) ([]byte, []yamlfile.Warning, error) {
	if filepath.Ext(path) != ".yaml" {
		return into, []yamlfile.Warning{}, nil
	}
	return yamlProcessor(
		from, into, persistenceComment,
	)
}

func mergeSort(
	from, into []byte, persistenceComment string,
) ([]byte, []yamlfile.Warning, error) {
	f, err := yamlfile.New(from)
	if err != nil {
		return nil, nil, err
	}
	i, err := yamlfile.New(into)
	if err != nil {
		return nil, nil, err
	}

	warnings, err := i.MergeSelective(f, persistenceComment)
	if err != nil {
		return nil, nil, fmt.Errorf("merge yamlfile error: %v", err)
	}
	i.Sort()

	var renderedData bytes.Buffer
	if err = i.Encode(&renderedData, 2); err != nil {
		return nil, nil, fmt.Errorf("encode yamlfile error: %v", err)
	}
	return renderedData.Bytes(), warnings, nil
}

func filePath(env string, tmpl template) string {
	envName := env
	if tmpl.namePrefix != "" {
		envName = fmt.Sprintf("%s-%s", tmpl.namePrefix, envName)
	}
	var fp string
	if tmpl.subpath != "" {
		fp = filepath.Join(tmpl.basepath, envName, tmpl.subpath)
	} else {
		fp = filepath.Join(tmpl.basepath, tmpl.subpath, fmt.Sprintf("%s.yaml", envName))
	}
	return fp
}

func versionIncompatible(content []byte, v version.SemVer) bool {
	matches := reVersion.FindStringSubmatch(string(content))
	if len(matches) < 2 {
		log.Sugar.Debugf("version string not found - ignoring")
		return true
	}
	majorVersion, _ := strconv.Atoi(matches[1])
	minorVersion, _ := strconv.Atoi(matches[2])

	if majorVersion != v.Major {
		log.Sugar.Debugf("incompatible major versions - ignoring")
		return true
	}
	if minorVersion > v.Minor {
		log.Sugar.Debugf("outdated CLI minor version (please update CLI) - ignoring")
		return true
	}
	return false
}

func openFileAsEmpty(path, contentHeader string) (f *os.File, err error) {
	if err = os.MkdirAll(filepath.Dir(path), allAllowed); err != nil {
		return
	}
	f, err = os.Create(path)
	if err != nil {
		return
	}
	_, err = f.WriteString(contentHeader)
	return
}

type ctx struct {
	log.Context
	report     *renderReport
	reportChan chan<- renderReport
}

func (c *ctx) AddDebug(lvl log.Level, key, value string) {
	if lvl.Is(log.Debug()) {
		c.Context[key] = value
	}
}

func (c *ctx) addReport(msg string, lvl log.Level, addedContext log.Context) {
	currentContext := make(log.Context, len(c.Context))
	for k, v := range c.Context {
		currentContext[k] = v
	}
	for k, v := range addedContext {
		currentContext[k] = v
	}
	c.report.items = append(c.report.items, logItem{msg, lvl, currentContext})
}

// checkErr holds the local logic for error checking in the render function.
// The render function runs concurrently and must send a renderReport back via the
// reportChan channel. This function does this if it finds an error.
// In addition, it returns true if a non-nil error was found, so that the render
// function exits subsequently.
func (c ctx) checkErr(msg string, err error) (exitNow bool) {
	if err != nil {
		c.Context.Log(msg, log.Error())
		c.addReport(err.Error(), log.Error(), log.Context{"error": err.Error()})
		c.reportChan <- *c.report
		return true
	}
	return false
}
